// This file is part of www.nand2tetris.org// and the book "The Elements of Computing Systems"// by Nisan and Schocken, MIT Press.// File name: projects/05/CPU.hdl/** * The Hack CPU (Central Processing unit), consisting of an ALU, * two registers named A and D, and a program counter named PC. * The CPU is designed to fetch and execute instructions written in  * the Hack machine language. In particular, functions as follows: * Executes the inputted instruction according to the Hack machine  * language specification. The D and A in the language specification * refer to CPU-resident registers, while M refers to the external * memory location addressed by A, i.e. to Memory[A]. The inM input  * holds the value of this location. If the current instruction needs  * to write a value to M, the value is placed in outM, the address  * of the target location is placed in the addressM output, and the  * writeM control bit is asserted. (When writeM==0, any value may  * appear in outM). The outM and writeM outputs are combinational:  * they are affected instantaneously by the execution of the current  * instruction. The addressM and pc outputs are clocked: although they  * are affected by the execution of the current instruction, they commit  * to their new values only in the next time step. If reset==1 then the  * CPU jumps to address 0 (i.e. pc is set to 0 in next time step) rather  * than to the address resulting from executing the current instruction.  */CHIP CPU {    //Instruction-breakdown: “ i     x  x   a   c  c  cccc   ddd   jjj ”.    //Index                   [15]  [14 13][12][11 10 9876] [543] [210]    //C-Description           "op"         "-----comp-----" "dest""jump"    IN  inM[16],         // M value input  (M = contents of R<AM[A])        instruction[16], // Instruction for execution        reset;           // Signals whether to re-start the current                         // program (reset==1) or continue executing                         // the current program (reset==0).    OUT outM[16],        // M value output        writeM,          // Write to M?         addressM[15],    // Address in data memory (of M)        pc[15];          // address of next instruction    PARTS:    //-----Instruction Decoding----//    //instruction[15] = 0, means excecute a-instruction. If this, the     //instruction bit needs to be inverted to a 1.    Not(in=instruction[15], out=aInstruction);    //--mux1    Mux16(a=instruction, b=ALUoutput, sel=instruction[15], out=mux1out);    //Do if A-instruction or instruction[5]=1. fig 4.4    Or(a=aInstruction, b=instruction[5], out=loadARegister);    //Does what above dictates    ARegister(in=mux1out, load=loadARegister, out=aOut, out[0..14] = addressM);    //if C-instruction and     And(a=instruction[15], b=instruction[12], out=mux2selector);    //mux2    Mux16(a=aOut, b=inM, sel=mux2selector, out=mux2out);    //Excecutes only if it is a c-instruction, and d[4] is 1. fig 4.4.    And(a=instruction[15], b=instruction[4], out=dLoad);        DRegister(in=ALUoutput, load=instruction[4], out=dOut);    //ALU    ALU(x = mux2out, y = dOut, out =ALUoutput, out =outM,         zx = instruction[11],        nx = instruction[10],        zy = instruction[9],        ny = instruction[8],        f  = instruction[7],        no = instruction[6],        zr = zrOut,        ng = ngOut);        //if d[m[A]] = 1, write to memory    And(a=true, b=instruction[3], out=writeM);    //Jump bits explained    //If ng = 1 do instruction[2]    And(a = ngOut, b = instruction[2], out = jumpNegative);    //If zr = 1 do instruction[1]    And(a = zrOut, b = instruction[1], out = jumpZero);    //If ng = 0 do instruction [0]    Not(in = ngOut, out = notNg);    And(a = notNg, b = instruction[0], out = jumpPositive);    Or(a = jumpNegative, b = jumpZero, out = or1);    Or(a = or1, b = jumpPositive, out = loadInput);    Not(in = loadInput, out = inctInput);    PC(in=aOut, load=loadInput, inc=inctInput, reset=reset, out[0..14]=pc[0..14]);     }
// This file is part of www.nand2tetris.org// and the book "The Elements of Computing Systems"// by Nisan and Schocken, MIT Press.// File name: projects/05/CPU.hdl/** * The Hack CPU (Central Processing unit), consisting of an ALU, * two registers named A and D, and a program counter named PC. * The CPU is designed to fetch and execute instructions written in  * the Hack machine language. In particular, functions as follows: * Executes the inputted instruction according to the Hack machine  * language specification. The D and A in the language specification * refer to CPU-resident registers, while M refers to the external * memory location addressed by A, i.e. to Memory[A]. The inM input  * holds the value of this location. If the current instruction needs  * to write a value to M, the value is placed in outM, the address  * of the target location is placed in the addressM output, and the  * writeM control bit is asserted. (When writeM==0, any value may  * appear in outM). The outM and writeM outputs are combinational:  * they are affected instantaneously by the execution of the current  * instruction. The addressM and pc outputs are clocked: although they  * are affected by the execution of the current instruction, they commit  * to their new values only in the next time step. If reset==1 then the  * CPU jumps to address 0 (i.e. pc is set to 0 in next time step) rather  * than to the address resulting from executing the current instruction.  */CHIP CPU {    //Instruction-breakdown: “ i     x  x   a   c  c  cccc   ddd   jjj ”.    //Index                   [15]  [14 13][12][11 10 9876] [543] [210]    //C-Description           "op"         "-----comp-----" "dest""jump"    IN  inM[16],         // M value input  (M = contents of R<AM[A])        instruction[16], // Instruction for execution        reset;           // Signals whether to re-start the current                         // program (reset==1) or continue executing                         // the current program (reset==0).    OUT outM[16],        // M value output        writeM,          // Write to M?         addressM[15],    // Address in data memory (of M)        pc[15];          // address of next instruction    PARTS:    //-----Instruction Decoding----//    //instruction[15] = 0, means excecute a-instruction. If this, the     //instruction bit needs to be inverted to a 1.    Not(in=instruction[15], out=aInstruction);    //--mux1    Mux16(a=instruction, b=ALUoutput, sel=instruction[15], out=mux1out);    //Do if A-instruction or instruction[5]=1. fig 4.4    Or(a=aInstruction, b=instruction[5], out=loadARegister);    //Does what above dictates    ARegister(in=mux1out, load=loadARegister, out=aOut, out[0..14] = addressM);    //if C-instruction and a is 1.     And(a=instruction[15], b=instruction[12], out=mux2selector);    //mux2    Mux16(a=aOut, b=inM, sel=mux2selector, out=mux2out);    //Excecutes only if it is a c-instruction, and d[4] is 1. fig 4.4.    And(a=instruction[15], b=instruction[4], out=dLoad);        DRegister(in=ALUoutput, load=dLoad, out=dOut);    //ALU, inputs explained in figure 4.3, just followed those    ALU(x = dOut , y = mux2out, out =ALUoutput, out =outM,         zx = instruction[11],        nx = instruction[10],        zy = instruction[9],        ny = instruction[8],        f  = instruction[7],        no = instruction[6],        zr = zr,        ng = ng);    //This section refers to figure 4.5, table with jump bit instrucitons    //If out = 0, do [start]    And(a = instruction[15], b = instruction[1], out = doZr);    And(a = zr, b = doZr, out = saveIfZero);    //If out = 0, do [stop]    //If out < 0, do [start]    And(a = instruction[15], b = instruction[2], out = doNg);    And(a = ng, b = doNg, out = saveIfNegative);    //If out < 0, do [stop]    //If out !< 0     Not(in = zr, out = notZr);    //If out != 0    Not(in = ng, out = notNg);    //if out > 0, do [start]    And(a = instruction[0], b = instruction[15], out = outPs);    //if number from APU != 0 && > 0, it must mean it is greater. If also jump bit [0] = 1, save.    And(a = notZr, b = notNg, out = notZrNg);    And(a = outPs, b = notZrNg, out = saveIfPositive);     //if out < 0, do [stop]    //if C-instruction and d[3], write to [M].    And(a=instruction[15], b=instruction[3], out=writeM);    //If negative and i[2] = 1, or zero and i[1] = 1.    Or(a = saveIfNegative, b = saveIfZero, out = saveIfZeroOrNegative);    //If one of the above or positive and i[0] = 0.    Or(a = saveIfZeroOrNegative, b = saveIfPositive, out = loadInput);    //If not loading, increment    Not(in = loadInput, out = inctInput);    //Takes from a-register, if load = 1. If load not increment, else increment and not load    PC(in=aOut, load=loadInput, inc=inctInput, reset=reset, out[0..14]=pc[0..14]);     }